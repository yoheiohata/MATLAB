function [f_out, a_out] = plotfft( varargin)
%PLOTFFT Plots a frequency-correct fft of the data in f (t = time in seconds, uniformly spaced)
%	PLOTFFT is intended to behave exactly like plot()
%
%	PLOTFFT(t,y) plots the frequency spectrum.  If t is in seconds, the frequency axis is true frequency in Hz.
%	PLOTFFT(r,t,y), where r is a nonzero scalar, first undersamples the dataset to get a sample frequency of r*f0, where
%	f0 is the fundamental frequency of the signal (determined by number of zero crossings).  Speeds up plotting 
%	in cases where the data is significantly oversampled (for example, if it was generated by multiplying two high 
%	frequency sinusoids to produce a lower frequency sinusoid.).  r = 16 is recommended.
%
%	PLOTFFT(t,y,S,...) or PLOTFFT(r,t,y,S,...) uses line style S and property-value pairs like plot() does.  See
%	documentation for plot.  If p-v pairs are used, S must be present.
%	PLOTFFT(t1,y1,S1,t2,y2,S2...) plots multiple lines.  Plotting n lines by using n*m y matrices is also supported.
%	PLOTFFT(t,y,S,...,'dB') plots 20*log10(|Y(f)|) instead of |Y(f)|
%	PLOTFFT(t,y,S,...,'dB_norm') is the same as above, except normalized so the peak value is 0dB.
%	If 'dB' or 'dB_norm' is used, they must be the last arguments, after any line style or p-v pairs for plot()	
%
%	[f,a] = PLOTFFT() returns the frequency and amplitude data used by the plot.
%   Uses the current figure or subplot.

if numel(varargin{1}) == 1
    % Reduce the data
    reduceval = varargin{1};
    new_varargin = varargin(2:end);
else
    reduceval = 0;
    new_varargin = varargin;
end
   
opt = '';
if ischar(varargin{end})
    opt = varargin{end};
	if any(strcmpi(opt, {'dB','dB_norm'}))
		new_varargin = new_varargin(1:end-1);
	end
end

for ii = 1:3:length(new_varargin)
    
    if ischar(new_varargin{ii})
		plot_varargin = [plot_varargin new_varargin(ii:end)];
        break;
    end
    
    t = new_varargin{ii};
    y = new_varargin{ii+1};

	if size(y,1) > 1 && size(y,2) == 1
		y = y';
	end
	
    if reduceval > 0
        [t,y] = Reduce(t,y,reduceval);
    end

    Fs = 1/(t(2)-t(1));

    L = size(y,2);
	
	if L ~= length(t)
		error('PLOTFFT:LENGTH','Lengths must match');
	end

    NFFT = 2^nextpow2(L); % Next power of 2 from length of t
    Y = fft(y,NFFT,2)/L;
    f = Fs/2*linspace(0,1,NFFT/2+1);

    if strcmpi(opt,'dB')
        Y = v2db(Y);
    elseif strcmpi(opt,'dB_norm')
        Y = v2db(Y);
        Y = Y - max(max(Y));
    else
        Y = abs(Y);
    end
    
    plot_varargin{ii} = f;
    plot_varargin{ii+1} = 2*(Y(:,1:NFFT/2+1));
    
    if length(new_varargin) >= ii+2
        plot_varargin{ii+2} = new_varargin{ii+2};
    end
    
end

if nargout >= 1
	% If there are outputs, return the data (only the first dataset supported)
	% but don't plot.
	f_out = plot_varargin{1};
	a_out = plot_varargin{2};
else
	
	plot_varargin = [plot_varargin(1:end) new_varargin(ii+3:end)];

	% Plot single-sided amplitude spectrum.
	plot(plot_varargin{1:end});
	title('Single-Sided Amplitude Spectrum')
	xlabel('Frequency (Hz)')

	if strcmpi(opt,'dB')
		ylabel('dB')
	elseif strcmpi(opt,'dB_norm')
		ylabel('dB(normalized)')
	else
	   ylabel('|Y(f)|')
	end

end

end



